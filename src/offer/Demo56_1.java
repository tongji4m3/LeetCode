package offer;

public class Demo56_1 {
    /*
    如果只有一个数字出现两次,直接异或运算即可
    任何一个数字异或自己两次都为0,而0异或一个数为他本身
    异或满足交换律

    想办法把数组分为两部分,每部分都包含一个只出现一次的数字
    第一步异或，相同的数其实都抵消了，剩下两个不同的数。这两个数异或结果肯定有某一位为1，不然都是0的话就是相同数。
    找到这个使得两个值不同的位,就是第一个为1的位置
    不同的两个数一个在此位为0，另一个为1。按此位将所有数分成两组，分开后各自异或，相同的两个数异或肯定为0（而且分开的时候，两个数必为一组）。剩下的每组里就是我门要找的数。
    */
    public int[] singleNumbers(int[] nums) {
        //第一步异或
        int k = 0;
        for (int num : nums) {
            k ^= num;
        }
        //找到这个位,使得两个值不同 即找到第一个1的位置
        int mask = 1;
        while ((k & mask) == 0) {
            mask = mask << 1;
        }

        //两个子数组分别异或
        int a = 0, b = 0;
        for (int num : nums) {
            if ((num & mask) == 0) {
                a ^= num;
            }
            else {
                b ^= num;
            }
        }

        return new int[]{a, b};
    }
}
