package offer;

public class Demo62 {
    /*
    第一轮是 [0, 1, 2, 3, 4] ，所以是 [0, 1, 2, 3, 4] 这个数组的多个复制。这一轮 2 删除了。

    第二轮开始时，从 3 开始，所以是 [3, 4, 0, 1] 这个数组的多个复制。这一轮 0 删除了。

    第三轮开始时，从 1 开始，所以是 [1, 3, 4] 这个数组的多个复制。这一轮 4 删除了。

    第四轮开始时，还是从 1 开始，所以是 [1, 3] 这个数组的多个复制。这一轮 1 删除了。

    最后剩下的数字是 3。


    看成是一个循环数组,画图可以发现,每轮都相当于把数组固定地向前移位 m 个位置

    反推

    最后剩下的 3 的下标是 0。

    第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，位置是(0 + 3) % 2 = 1。

    第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，位置是(1 + 3) % 3 = 1。

    第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，位置是(1 + 3) % 4 = 0。

    第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，位置是(0 + 3) % 5 = 3。


    反推的过程:(当前index + m) % 上一轮剩余数字的个数
    */
    public int lastRemaining(int n, int m) {
        //ans代表当前位置
        int ans = 0;
        // 最后一轮剩下2个数，所以从2开始反推
        //因为n个数,每次去掉一个,最后剩下一个,所以一共n-1轮
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
}
