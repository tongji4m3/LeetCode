```
共有都是ñ课程，你必须采取从标记0到n-1。

有些课程可能有先决条件，例如要学习0，你必须先修课程1，这表示为一对： [0,1]

鉴于课程总数和先决条件对列表，您是否可以完成所有课程？

例1：

输入： 2，[[1,0]] 
输出： true
说明：  共有2门课程。
要修课程1，你应该完成课程0.所以有可能。
例2：

输入： 2，[[1,0]，[0,1]]
输出： false
说明：  共有2门课程。
要修课程1，你应该完成课程0，并且你需要修课程0
也完成了课程1.所以这是不可能的。
注意：

输入先决条件是由边列表而不是邻接矩阵表示的图。详细了解图表的表示方式。
您可以假设输入先决条件中没有重复的边。
```

```c++
class Solution
{
public:
	bool canFinish(int n, vector<vector<int>>& pre)
	{
		//以[0,1]为例
		vector<vector<int>> adj(n, vector<int>());//[0,1]则代表1->0,则存1,0
		vector<int> degree(n, 0);//代表每一个在能用之前的先决条件

		for (auto& i : pre)
		{
			adj[i[1]].push_back(i[0]);//存入1,0
			++degree[i[0]];//0有一个先决条件了
		}
		queue<int> q;//存储没先决条件的工序的索引

		for (int i = 0; i != degree.size(); ++i)
		{
			if (degree[i] == 0)//注意比较的是值，存的是索引
			{
				q.push(i);
			}
		}

		//如果上一循环中没存入，则不会进行这个循环，说明了死结
		while (!q.empty())
		{
			int k = q.front();//front在顶部
			q.pop();
			--n;
			for (auto& i : adj[k])//以k为先决条件的-1
			{
				//这里的i就代表了工序的索引
				if (--degree[i] == 0)
				{
					q.push(i);
				}
			}
		}

		//以n来算，如果每一个都搞定了，那么就完美解决
		return n == 0;
	}
}; 
```
